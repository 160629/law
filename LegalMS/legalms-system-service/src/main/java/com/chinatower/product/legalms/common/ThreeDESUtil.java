package com.chinatower.product.legalms.common;import java.io.UnsupportedEncodingException;import org.bouncycastle.crypto.engines.DESEngine;import org.bouncycastle.crypto.params.KeyParameter;import org.slf4j.Logger;import org.slf4j.LoggerFactory;/** * 3DES加密 *  * @author zhaixiaoqing * @date 2017-10-19 */public class ThreeDESUtil {    private ThreeDESUtil() {        throw new IllegalStateException("Utility class");    }    private static final Logger logger = LoggerFactory.getLogger("TransLog");    private static final String CHARSET = "ISO-8859-1";        private static final byte[] HEX_DIGITS = {48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70};        private static final String KEY = "6#dPz>3F";        private static DESEngine cipher = new DESEngine();        private static byte[] groupingEncrypt(byte[] key, byte[] data) {        int range = 8;        int iRet = data.length % range;        byte[] out;        if (iRet > 0) {            int length = data.length + (range - iRet);            out = new byte[length];        }        else {            out = new byte[data.length];        }        cipher.init(true, new KeyParameter(key));        int i;        for (i = 0; i < data.length / range; i++) {            cipher.processBlock(data, i * range, out, i * range);        }        if (iRet > 0) {            byte[] temp = new byte[range];            System.arraycopy(data, i * range, temp, 0, iRet);            temp[iRet] = -128;            cipher.processBlock(temp, 0, out, i * range);        }        byte[] toasc = new byte[out.length * 2];        int k = 0;        int j = 0;        for (i = 0; i < out.length; i++) {            k = out[i];            toasc[j++] = HEX_DIGITS[k >>> 4 & 0xf];            toasc[j++] = HEX_DIGITS[k & 0xf];        }                return toasc;    }        private static byte[] groupingDecrypt(byte[] key, byte[] data) {        int range = 2;        int group = 8;        int k = 0;        byte[] tobyte = new byte[data.length / range];        for (int i = 0; i < data.length; i += range) {            char ch;            if (data[i] <= 57) {                ch = (char)(data[i] & 0xf);            }            else {                ch = (char)((data[i] & 0xf) + 9);            }            ch <<= '\004';            if (data[i + 1] <= 57) {                ch |= data[i + 1] & 0xf;            }            else {                ch |= (data[i + 1] & 0xf) + 9;            }            tobyte[k] = (byte)ch;            k++;        }                cipher.init(false, new KeyParameter(key));        if (tobyte.length % group == 0) {            byte[] out = new byte[tobyte.length];            for (int i = 0; i < tobyte.length / group; i++) {                cipher.processBlock(tobyte, i * group, out, i * group);            }            int len = padCount(out);            byte[] deout = new byte[out.length - len];            System.arraycopy(out, 0, deout, 0, out.length - len);            return deout;        }        else {            return new byte[0];//null;        }    }        private static int padCount(byte[] in) {        int count;        for (count = in.length; count > 0; count--) {            if (in[count - 1] != 0) {                break;            }        }        int minNum = -128;        if (in[count - 1] == minNum) {            return (in.length - count) + 1;        }        else {            return in.length - count;        }    }        /**     * 加密     *      * @param code     * @return     */    public static final  String encode(String code) {        if (code == null) {            return null;        }        else {            try {                byte[] cryptogragh = groupingEncrypt(KEY.getBytes(CHARSET), code.getBytes(CHARSET));                return new String(cryptogragh, CHARSET);            }            catch (UnsupportedEncodingException e) {                logger.error(ConstClass.FAILURE.FAILURE_MESS,e);                return null;            }        }    }        /**     * 解密     *      * @param code     * @return     */    public static final  String decode(String code) {        if (code == null) {            return null;        }        else {            try {                byte[] debyte = groupingDecrypt(KEY.getBytes(CHARSET), code.getBytes(CHARSET));                return debyte.length>0 ? new String(debyte, CHARSET) : null;            }            catch (UnsupportedEncodingException e) {                return null;            }        }    }        /*public static void main(String[] args) {        // System.out.println(ThreeDesUtil.encode(JsonMapper.toJsonString(paramsInfo)));        // System.out.println(ThreeDESUtil.decode(ThreeDESUtil.encode("bwda123!@#")));//        System.out.println(ThreeDESUtil.encode("Minjun@0402"));        System.out.println(ThreeDESUtil.decode("D6DCF0DB6D8BD28C"));    }*/    /*public static void main(String[] args){      System.out.println(new byte[0]);        System.out.println(new byte[0].length);    }*/    }